<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>TTY-ART-GENERATOR</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #ddd; padding: 1em; }
    input, select, button, textarea, label { margin: 0.5em 0; width: 100%; }
    textarea { font-family: monospace; background: #222; color: #0f0; resize: vertical; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5em; }
    .inline { display:flex; gap:1em; align-items:center; }
  </style>
</head>
<body>
  <h2>TTY ART AFSK GENERATOR</h2>
<p style="font-size:0.9em; color:#aaa; margin-top:-0.5em;">
  Select an image or type text. Adjust width, brightness, contrast, and aspect ratio.  
  Click "Convert Image" to preview as ASCII art. Based on Model 28 Character set "#ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;.,-'()/&$?! "
</p>
  <label>Character Set (for image):</label>
  <select id="asciiRamp">
	 <option value="custom">CUSTOM (see below)</option>
    <option value=" #O.-">BOLD:#O.-</option>
    <option value=" &#O-.">SHADED:&#O-</option>
    <option value=" #XO.">TIGHT:#XO.</option>
    <option value="#MW$&I:-. ">ASCII-ISH:#MW$&I:-.</option>
  </select>

  <label>Custom Character Set:</label>
  <input type="text" id="customRamp" value="#MW$&. ">

  <div class="row">
    <label>Brightness (0.5 = normal):
      <input type="number" step="0.1" id="brightness" value="0.5">
    </label>
    <label>Contrast (1 = normal):
      <input type="number" step="0.1" id="contrast" value="1.0">
    </label>
  </div>

  <div class="row">
    <label>Threshold (0..255; 0 = grayscale)
      <input type="number" min="0" max="255" id="threshold" value="0">
    </label>
    <label>ASCII Width (characters):
      <input type="number" id="asciiWidth" value="72">
    </label>
  </div>

  <div class="row">
    <label>Vertical Scale (aspect):
      <input type="number" step="0.1" id="vScale" value="0.5">
    </label>
    <label></label>
  </div>

  <div class="inline" style="justify-content:flex-start;">
    <label class="inline" style="width:auto;"><input type="checkbox" id="invert"> Invert image</label>
    
  </div>

  <label>Select Image:</label>
  <input type="file" id="imageInput" accept="image/*">

  <button onclick="generateASCII()" style="background-color:#0f0; color:#000; font-weight:bold; border:2px solid #0c0;">Convert Image</button>
  <textarea id="asciiOutput" rows="6"></textarea>
  <audio id="asciiAudioPlayer" controls style="display:block; margin-top:1em;"></audio>
  
<h2>TTY TEXT AFSK GENERATOR</h2>
<p style="font-size:0.9em; color:#aaa; margin-top:-0.5em;">
  Type your text and click "Generate AFSK WAV"
  Based on Model 28 Character set "#ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;.,-'()/&$?! "
  <label>Enter text below:</label>
  <textarea id="textInput">HELLORLD</textarea>
    <button onclick="generateWavAFSK()" style="background-color:#0f0; color:#000; font-weight:bold; border:2px solid #0c0;">Generate AFSK WAV</button>
  <audio id="audioPlayer" controls style="display:block; margin-top:1em;"></audio>
<h2>GLOBAL SETTINGS</h2>
  <div class="row">
    <label>Baud Rate:
      <input type="number" id="baudRate" value="45.45">
    </label>
    <label>Stop Bits:
      <input type="number" step="0.1" id="stopBits" value="1.5">
    </label>
  </div>

  <div class="row">
    <label>Mark Frequency (Hz):
      <input type="number" id="markFreq" value="2125">
    </label>
    <label>Space Frequency (Hz):
      <input type="number" id="spaceFreq" value="2295">
    </label>
  </div>

  <div class="row">
    <label>Mechanical Delay after shift (ms):
      <input type="number" id="mechDelayMs" value="200">
    </label>
    <div><label class="inline" style="width:auto;">
  <input type="checkbox" id="swapSense">
  Reverse mark/space (invert sense)
</label></div>
  </div>




  <canvas id="asciiCanvas" style="display:none"></canvas>

  <script>
    // Safe mapping
    const printableSet = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;.,-'()/&$?! ";
    const replacementMap = {
      '"': "'", '=': '-', '*': 'X', '_': '-', '@': 'A', '%': 'O',
      '[': '(', ']': ')', '{': '(', '}': ')', '\\': '/', '^': '-', '|': '/',
      '`': "'", '~': '-', '<': '(', '>': ')'
    };
    const normalizeChar = ch => {
      const u = ch.toUpperCase();
      const safe = replacementMap[u] || replacementMap[ch] || u;
      return printableSet.includes(safe) ? safe : ' ';
    };

    // ITA2
    const LTRS = 0b11111, FIGS = 0b11011;
    const BAUDOT_TABLE = {
      LTRS: {
        'A': 0b00011, 'B': 0b11001, 'C': 0b01110, 'D': 0b01001,
        'E': 0b00001, 'F': 0b01101, 'G': 0b11010, 'H': 0b10100,
        'I': 0b00110, 'J': 0b01011, 'K': 0b01111, 'L': 0b10010,
        'M': 0b11100, 'N': 0b01100, 'O': 0b11000, 'P': 0b10110,
        'Q': 0b10111, 'R': 0b01010, 'S': 0b00101, 'T': 0b10000,
        'U': 0b00111, 'V': 0b11110, 'W': 0b10011, 'X': 0b11101,
        'Y': 0b10101, 'Z': 0b10001, '\r': 0b01000, '\n': 0b00010, ' ': 0b00100
      },
      FIGS: {
        '-': 0b00011, '?': 0b11001, ':': 0b01110, '$': 0b01001,
        '3': 0b00001, '!': 0b01101, '&': 0b11010, '#': 0b10100,
        '8': 0b00110, "'": 0b01011, '(': 0b01111, ')': 0b10010,
        '.': 0b11100, ',': 0b01100, '9': 0b11000, '0': 0b10110,
        '1': 0b10111, '4': 0b01010, 'Bell': 0b00101, '5': 0b10000,
        '7': 0b00111, ';': 0b11110, '2': 0b10011, '/': 0b11101,
        '6': 0b10101, '+': 0b10001, '\r': 0b01000, '\n': 0b00010, ' ': 0b00100, '\a': 0b00101
      }
    };

    // Build frames; force CR LF + LTRS at start and end
    function buildBaudotFramesFromText(text, mechDelaySec) {
      const frames = [];
      let currentShift = null;

      // sync start
      frames.push({ type: 'char', code: BAUDOT_TABLE.LTRS['\r'] });
      frames.push({ type: 'char', code: BAUDOT_TABLE.LTRS['\n'] });
      frames.push({ type: 'char', code: LTRS });

      for (const raw of text) {
        const ch = normalizeChar(raw);

        let needed = null;
        if (ch in BAUDOT_TABLE.LTRS) needed = 'LTRS';
        else if (ch in BAUDOT_TABLE.FIGS) needed = 'FIGS';
        else continue;

        if (needed !== currentShift) {
          frames.push({ type: 'char', code: (needed === 'LTRS' ? LTRS : FIGS) });
          if (mechDelaySec > 0) frames.push({ type: 'hold', sec: mechDelaySec });
          currentShift = needed;
        }

        frames.push({ type: 'char', code: BAUDOT_TABLE[needed][ch] });
      }

      if (currentShift !== 'LTRS') frames.push({ type: 'char', code: LTRS });
      frames.push({ type: 'char', code: BAUDOT_TABLE.LTRS['\r'] });
      frames.push({ type: 'char', code: BAUDOT_TABLE.LTRS['\n'] });

      return frames;
    }

    // Audio helpers
    function addMarkHold(signal, sec, markFreq, sampleRate) {
      const n = Math.max(0, Math.floor(sec * sampleRate));
      for (let i = 0; i < n; i++) {
        signal.push(Math.sin(2 * Math.PI * markFreq * (i / sampleRate)));
      }
    }
    function generateMarkPreamble(durationSec, markFreq, sampleRate = 44100) {
      const sig = [];
      addMarkHold(sig, durationSec, markFreq, sampleRate);
      return sig;
    }
    function encodeWav(samples, sampleRate) {
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);
      const writeStr = (off, s) => { for (let i = 0; i < s.length; i++) view.setUint8(off + i, s.charCodeAt(i)); };
      writeStr(0, 'RIFF'); view.setUint32(4, 36 + samples.length * 2, true);
      writeStr(8, 'WAVEfmt '); view.setUint32(16, 16, true);
      view.setUint16(20, 1, true); view.setUint16(22, 1, true);
      view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true);
      view.setUint16(32, 2, true); view.setUint16(34, 16, true);
      writeStr(36, 'data'); view.setUint32(40, samples.length * 2, true);
      samples.forEach((s, i) => view.setInt16(44 + i * 2, Math.max(-1, Math.min(1, s)) * 32767, true));
      return buffer;
    }

    // Frames -> Audio
    function afskFromFrames(frames, opts) {
      const { baud, mark, space, stopBits, sampleRate, swapSense } = opts;
      const bitDur = 1 / baud;
      const samplesPerBit = Math.floor(sampleRate * bitDur);
      const signal = [];

      signal.push(...generateMarkPreamble(2.0, mark, sampleRate));

      for (const f of frames) {
        if (f.type === 'hold') {
          addMarkHold(signal, f.sec, mark, sampleRate);
          continue;
        }
        if (f.type === 'char') {
          const code = f.code;

          // start bit (SPACE = 0)
          const startFreq = swapSense ? mark : space;
          for (let i = 0; i < samplesPerBit; i++) {
            signal.push(Math.sin(2 * Math.PI * startFreq * (i / sampleRate)));
          }
          // 5 data bits, LSB-first
          for (let i = 0; i < 5; i++) {
            const bit = (code >> i) & 1;
            const freq = (bit ^ (swapSense ? 1 : 0)) ? mark : space;
            for (let j = 0; j < samplesPerBit; j++) {
              signal.push(Math.sin(2 * Math.PI * freq * (j / sampleRate)));
            }
          }
          // stop bits (MARK)
          const stopSamples = Math.floor(samplesPerBit * stopBits);
          for (let i = 0; i < stopSamples; i++) {
            signal.push(Math.sin(2 * Math.PI * mark * (i / sampleRate)));
          }
        }
      }

      return signal;
    }

    // Image -> ASCII with vertical scaling; auto-resize preview
    function generateASCII() {
      const file = document.getElementById('imageInput').files[0];
      if (!file) return alert('No image selected');

      const canvas = document.getElementById('asciiCanvas');
      const ctx = canvas.getContext('2d');

      const width = parseInt(document.getElementById('asciiWidth').value);
      const vScale = parseFloat(document.getElementById('vScale').value) || 1.0; // <â€” aspect control
      let ramp = document.getElementById('asciiRamp').value;
      if (ramp === 'custom') ramp = document.getElementById('customRamp').value;

      const reader = new FileReader();
      const img = new Image();
      reader.onload = e => { img.src = e.target.result; };
      img.onload = () => {
        const ratio = img.height / img.width;
        canvas.width = width;
        canvas.height = Math.max(1, Math.round(width * ratio * vScale)); // keep line length; scale rows

        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        const brightness = parseFloat(document.getElementById('brightness').value);
        const contrast = parseFloat(document.getElementById('contrast').value);
        const threshold = parseInt(document.getElementById('threshold').value);
        const invert = document.getElementById('invert').checked;

        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const adjust = v => Math.min(255, Math.max(0, (v - 128) * contrast + 128 + brightness * 128 - 64));
        for (let i = 0; i < imgData.data.length; i += 4) {
          let avg = (imgData.data[i] + imgData.data[i+1] + imgData.data[i+2]) / 3;
          avg = adjust(avg);
          if (invert) avg = 255 - avg;
          if (threshold > 0) avg = avg < threshold ? 0 : 255;
          imgData.data[i] = imgData.data[i+1] = imgData.data[i+2] = avg;
        }
        ctx.putImageData(imgData, 0, 0);

        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        let output = '';
        for (let y = 0; y < canvas.height; y++) {
          for (let x = 0; x < canvas.width; x++) {
            const idx = (y * canvas.width + x) * 4;
            const val = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            output += ramp.charAt(Math.floor(val / 256 * ramp.length));
          }
          output += '\n';
        }

        const asciiBox = document.getElementById('asciiOutput');
        asciiBox.value = output;
        asciiBox.rows = Math.max(6, output.split('\n').length);

        const asciiText = [...output].map(normalizeChar).join('');
        makeAudio(asciiText, document.getElementById('asciiAudioPlayer'));
      };
      reader.readAsDataURL(file);
    }

    function makeAudio(text, audioEl) {
      const baud = parseFloat(document.getElementById('baudRate').value);
      const mark = parseFloat(document.getElementById('markFreq').value);
      const space = parseFloat(document.getElementById('spaceFreq').value);
      const stopBits = parseFloat(document.getElementById('stopBits').value);
      const mechMs = parseFloat(document.getElementById('mechDelayMs').value) || 0;
      const mechSec = Math.max(0, mechMs / 1000);
      const swapSense = (document.getElementById('swapSense')?.checked) || false;


      const frames = buildBaudotFramesFromText(text, mechSec);
      const signal = afskFromFrames(frames, {
        baud, mark, space, stopBits, sampleRate: 44100, swapSense
      });
      const wav = encodeWav(signal, 44100);
      const url = URL.createObjectURL(new Blob([wav], { type: 'audio/wav' }));
      audioEl.src = url;
    }

    function generateWavAFSK() {
      const textInput = document.getElementById('textInput').value;
      const asciiText = [...textInput].map(normalizeChar).join('');
      makeAudio(asciiText, document.getElementById('audioPlayer'));
    }
  </script>
</body>
</html>
