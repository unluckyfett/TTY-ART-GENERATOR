<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>TTY-ART-GENERATOR</title>
  <style>
    body { font-family: sans-serif; background:#111; color:#ddd; padding:1em; }
    input, select, button, textarea, label { margin:0.5em 0; width:100%; }
    textarea { font-family: monospace; background:#222; color:#0f0; resize:vertical; white-space:pre; overflow:auto; }
    .row { display:grid; grid-template-columns:1fr 1fr; gap:0.5em; }
    .inline { display:flex; gap:1em; align-items:center; }
  </style>
</head>
<body>
  

  <h2>TTY ART AFSK GENERATOR</h2>
  <p style="font-size:0.9em; color:#aaa; margin-top:-0.5em;">
    Select an image or type text. Adjust width, brightness, contrast, and aspect ratio.
    Click "Convert Image" to preview as TTY art. Output is masked to:
    "#ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;.,-'()/&$?! "
  </p>

  <label>Character Set (for image):</label>
  <select id="asciiRamp">
    <option value="custom">CUSTOM (see below)</option>
    <option value=" 0#.-">BOLD:#-0.</option>
    <option value=" 0&#-.">SHADED:#&0-</option>
    <option value=" #&0.">TIGHT:#&0.</option>
    <option value="#MW$&I:-. ">ASCII-ISH:#MW$&I:-.</option>
  </select>

  <label>Custom Character Set:</label>
  <input type="text" id="customRamp" value="#MW$&. ">

  <div class="row">
    <label>Brightness (0.5 = normal):
      <input type="number" step="0.1" id="brightness" value="0.5">
    </label>
    <label>Contrast (1 = normal):
      <input type="number" step="0.1" id="contrast" value="1.0">
    </label>
  </div>

  <div class="row">
    <label>Threshold (0-255; 0 = grayscale)
      <input type="number" min="0" max="255" id="threshold" value="0">
    </label>
    <label>Line Width (characters):
      <input type="number" id="asciiWidth" value="72">
    </label>
  </div>

  <div class="row">
    <label>Vertical Scale (aspect):
      <input type="number" step="0.1" id="vScale" value="0.6">
    </label>
    <label></label>
  </div>

  <div class="inline" style="justify-content:flex-start;">
    <label class="inline" style="width:auto;"><input type="checkbox" id="invert"> Invert image</label>
  </div>

  <label>Select Image:</label>
  <input type="file" id="imageInput" accept="image/*">

  <button onclick="generateASCII()" style="background-color:#0f0; color:#000; font-weight:bold; border:2px solid #0c0;">Convert Image</button>
  <textarea id="asciiOutput" rows="20" cols="72" wrap="off" spellcheck="false"></textarea>
  <audio id="asciiAudioPlayer" controls style="display:block; margin-top:1em;"></audio>

  <h2>TTY TEXT AFSK GENERATOR</h2>
  <p style="font-size:0.9em; color:#aaa; margin-top:-0.5em;">
    Type your text and click "Generate AFSK WAV".
  </p>
  <label>Enter text below:</label>
  <textarea id="textInput">RYRYRYRY</textarea>
  <button onclick="generateWavAFSK()" style="background-color:#0f0; color:#000; font-weight:bold; border:2px solid #0c0;">Generate AFSK WAV</button>
  <audio id="audioPlayer" controls style="display:block; margin-top:1em;"></audio>

  <h2>GLOBAL SETTINGS</h2>
  <div class="row">
    <label>Baud Rate:
      <input type="number" id="baudRate" value="45.45">
    </label>
    <label>Stop Bits:
      <input type="number" step="0.1" id="stopBits" value="1.5">
    </label>
  </div>

  <div class="row">
    <label>Mark Frequency (Hz):
      <input type="number" id="markFreq" value="2125">
    </label>
    <label>Space Frequency (Hz):
      <input type="number" id="spaceFreq" value="2295">
    </label>
  </div>

  <img src="logo.png" alt="Logo" style="height:75px; width:auto;">
  <p style="font-size:0.8em; color:#888;">
    © 2025 Frankie Caswell — Licensed under
    <a href="https://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>.
  </p>

  <canvas id="asciiCanvas" style="display:none"></canvas>
<script data-goatcounter="https://unluckyfett.goatcounter.com/count"
        async src="//gc.zgo.at/count.js"></script>
  <script>
    // ---------- Safe mapping ----------
    const printableSet = "#ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789:;.,-'()/&$?! ";
    const replacementMap = {
      '"':"'", '=':'-', '*':'X', '_':'-', '@':'A', '%':'O',
      '[':'(', ']':')', '{':'(', '}':')', '\\':'/', '^':'-', '|':'/',
      '`':"'", '~':'-', '<':'(', '>':')'
    };
    const normalizeChar = ch => {
      if (ch === '\r' || ch === '\n') return ch; // keep CR/LF
      const u = ch.toUpperCase();
      const safe = replacementMap[u] || replacementMap[ch] || u;
      return printableSet.includes(safe) ? safe : ' ';
    };
    const normalizeText = s => [...s].map(normalizeChar).join('');

    // ---------- ITA2 ----------
    const LTRS = 0b11111, FIGS = 0b11011;
    const BAUDOT_TABLE = {
      LTRS: {
        'A':0b00011,'B':0b11001,'C':0b01110,'D':0b01001,'E':0b00001,'F':0b01101,'G':0b11010,'H':0b10100,
        'I':0b00110,'J':0b01011,'K':0b01111,'L':0b10010,'M':0b11100,'N':0b01100,'O':0b11000,'P':0b10110,
        'Q':0b10111,'R':0b01010,'S':0b00101,'T':0b10000,'U':0b00111,'V':0b11110,'W':0b10011,'X':0b11101,
        'Y':0b10101,'Z':0b10001,'\r':0b01000,'\n':0b00010,' ':0b00100
      },
      FIGS: {
        '-':0b00011,'?':0b11001,':':0b01110,'$':0b01001,'3':0b00001,'!':0b01101,'&':0b11010,'#':0b10100,
        '8':0b00110,"'":0b01011,'(':0b01111,')':0b10010,'.':0b11100,',':0b01100,'9':0b11000,'0':0b10110,
        '1':0b10111,'4':0b01010,'Bell':0b00101,'5':0b10000,'7':0b00111,';':0b11110,'2':0b10011,'/':0b11101,
        '6':0b10101,'+':0b10001,'\r':0b01000,'\n':0b00010,' ':0b00100,'\a':0b00101
      }
    };

    // ---------- Guards & timing (all zero to keep CRLF tight) ----------
    const GUARD_SHIFT_BITS = 0.0; // after FIGS/LTRS (bump to 0.5–1.0 if needed)
    const GUARD_CR_BITS    = 0.0; // after CR
    const GUARD_LF_BITS    = 0.0; // after LF
    const LINE_LEAD_MS     = 0;   // per-line lead (0 = none)
    const START_LEAD_MS    = 0;   // file-start lead (0 = none)
    const DEFAULT_STRETCH  = 1.002; // slight safety; set 1.000 if you want exact

    // ---------- Frames builder with CR-before-LF injection ----------
    function buildBaudotFramesFromText(text) {
      const frames = [];
      let currentShift = null;
      let lastWasCR = false;

      // Minimal initial sync (optional; tiny and fast)
      frames.push({ type:'char', code: BAUDOT_TABLE.LTRS['\r'], guardBits: GUARD_CR_BITS });
      frames.push({ type:'char', code: BAUDOT_TABLE.LTRS['\n'], guardBits: GUARD_LF_BITS });
      frames.push({ type:'char', code: LTRS,                     guardBits: GUARD_SHIFT_BITS });
      if (START_LEAD_MS > 0) frames.push({ type:'hold', sec: START_LEAD_MS/1000 });

      for (const raw of text) {
        const ch = normalizeChar(raw);

        // CR
        if (ch === '\r') {
          frames.push({ type:'char', code: BAUDOT_TABLE.LTRS['\r'], guardBits: GUARD_CR_BITS });
          lastWasCR = true;
          continue;
        }

        // LF — ensure CRLF (inject CR if not already)
        if (ch === '\n') {
          if (!lastWasCR) {
            frames.push({ type:'char', code: BAUDOT_TABLE.LTRS['\r'], guardBits: GUARD_CR_BITS });
          }
          frames.push({ type:'char', code: BAUDOT_TABLE.LTRS['\n'], guardBits: GUARD_LF_BITS });
          lastWasCR = false;
          if (LINE_LEAD_MS > 0) frames.push({ type:'hold', sec: LINE_LEAD_MS/1000 });
          continue;
        }

        lastWasCR = false;

        // Shift handling
        let needed = null;
        if (ch in BAUDOT_TABLE.LTRS) needed = 'LTRS';
        else if (ch in BAUDOT_TABLE.FIGS) needed = 'FIGS';
        else continue;

        if (needed !== currentShift) {
          frames.push({ type:'char', code: (needed === 'LTRS' ? LTRS : FIGS), guardBits: GUARD_SHIFT_BITS });
          currentShift = needed;
        }
        frames.push({ type:'char', code: BAUDOT_TABLE[needed][ch] });
      }

      // Tidy end
      if (currentShift !== 'LTRS') frames.push({ type:'char', code: LTRS, guardBits: GUARD_SHIFT_BITS });
      frames.push({ type:'char', code: BAUDOT_TABLE.LTRS['\r'], guardBits: GUARD_CR_BITS });
      frames.push({ type:'char', code: BAUDOT_TABLE.LTRS['\n'], guardBits: GUARD_LF_BITS });

      return frames;
    }

    // ---------- Audio helpers ----------
    let audioCtx;
    function getSampleRate() {
      try {
        if (!audioCtx) {
          const Ctx = window.AudioContext || window.webkitAudioContext;
          audioCtx = new Ctx();
        }
        const sr = audioCtx.sampleRate | 0;
        if (sr >= 8000 && sr <= 192000) return sr;
      } catch (e) {
        console.warn('AudioContext unavailable; using 48000', e);
      }
      return 48000;
    }

    // Phase-continuous, fractional-bit DDS AFSK
    function afskFromFrames(frames, opts) {
      const { baud, mark, space, stopBits, sampleRate, stretch = DEFAULT_STRETCH } = opts;
      const twoPi = 2 * Math.PI;
      const spbF = (sampleRate / baud) * stretch; // fractional samples/bit
      let carry = 0, phase = 0;
      const out = [];

      const emit = (freq, bitUnits) => {
        let total = spbF * bitUnits + carry;
        let n = Math.floor(total);
        carry = total - n;
        const inc = twoPi * freq / sampleRate;
        for (let i = 0; i < n; i++) {
          out.push(Math.sin(phase));
          phase += inc;
          if (phase >= twoPi) phase -= twoPi;
        }
      };

      // No global lead-in
      for (const f of frames) {
        if (f.type === 'hold') { emit(opts.mark, f.sec * baud); continue; }
        if (f.type === 'char') {
          const code = f.code & 0x1F;
          emit(space, 1);                 // start bit (SPACE = 0)
          for (let i = 0; i < 5; i++) {   // data bits LSB-first
            const bit = (code >> i) & 1;
            emit(bit ? mark : space, 1);
          }
          emit(mark, stopBits);           // stop bits
          if (f.guardBits && f.guardBits > 0) emit(mark, f.guardBits); // (zero by default)
        }
      }

      emit(mark, 2.0); // tail MARK
      return out;
    }

    function encodeWav(samples, sampleRate) {
      const buffer = new ArrayBuffer(44 + samples.length * 2);
      const view = new DataView(buffer);
      const writeStr = (off, s) => { for (let i = 0; i < s.length; i++) view.setUint8(off + i, s.charCodeAt(i)); };
      writeStr(0,'RIFF'); view.setUint32(4, 36 + samples.length*2, true);
      writeStr(8,'WAVEfmt '); view.setUint32(16,16,true);
      view.setUint16(20,1,true); view.setUint16(22,1,true);
      view.setUint32(24,sampleRate,true); view.setUint32(28,sampleRate*2,true);
      view.setUint16(32,2,true); view.setUint16(34,16,true);
      writeStr(36,'data'); view.setUint32(40, samples.length*2, true);
      for (let i=0;i<samples.length;i++){
        const s = Math.max(-1, Math.min(1, samples[i])) * 32767;
        view.setInt16(44 + i*2, s|0, true);
      }
      return buffer;
    }

    // ---------- Image -> ASCII -> Audio ----------
    function generateASCII() {
      const file = document.getElementById('imageInput').files[0];
      if (!file) return alert('No image selected');
      const canvas = document.getElementById('asciiCanvas');
      const ctx = canvas.getContext('2d');

      const width = parseInt(document.getElementById('asciiWidth').value);
      const vScale = parseFloat(document.getElementById('vScale').value) || 1.0;
      let ramp = document.getElementById('asciiRamp').value;
      if (ramp === 'custom') ramp = document.getElementById('customRamp').value;

      const reader = new FileReader();
      const img = new Image();
      reader.onload = e => { img.src = e.target.result; };
      img.onload = () => {
        const ratio = img.height / img.width;
        canvas.width = width;
        canvas.height = Math.max(1, Math.round(width * ratio * vScale));
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        const brightness = parseFloat(document.getElementById('brightness').value);
        const contrast = parseFloat(document.getElementById('contrast').value);
        const threshold = parseInt(document.getElementById('threshold').value);
        const invert = document.getElementById('invert').checked;

        let imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const adjust = v => Math.min(255, Math.max(0, (v - 128) * contrast + 128 + brightness * 128 - 64));
        for (let i=0; i<imgData.data.length; i+=4) {
          let avg = (imgData.data[i]+imgData.data[i+1]+imgData.data[i+2]) / 3;
          avg = adjust(avg);
          if (invert) avg = 255 - avg;
          if (threshold > 0) avg = avg < threshold ? 0 : 255;
          imgData.data[i]=imgData.data[i+1]=imgData.data[i+2]=avg;
        }
        ctx.putImageData(imgData, 0, 0);

        const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        let output = '';
        for (let y=0; y<canvas.height; y++) {
          for (let x=0; x<canvas.width; x++) {
            const idx = (y*canvas.width + x)*4;
            const val = (data[idx] + data[idx+1] + data[idx+2]) / 3;
            output += ramp.charAt(Math.floor(val/256 * ramp.length));
          }
          output += '\r\n';
        }

        const asciiBox = document.getElementById('asciiOutput');
        asciiBox.value = output;
        asciiBox.setAttribute('wrap','off');
        asciiBox.cols = width;
        asciiBox.style.whiteSpace = 'pre';
        asciiBox.rows = Math.max(6, output.split('\n').length);

        makeAudio(normalizeText(output), document.getElementById('asciiAudioPlayer'));
      };
      reader.readAsDataURL(file);
    }

    // ---------- Text -> Audio ----------
    function makeAudio(text, audioEl) {
      try {
        const baud  = parseFloat(document.getElementById('baudRate').value);
        const mark  = parseFloat(document.getElementById('markFreq').value);
        const space = parseFloat(document.getElementById('spaceFreq').value);
        const stopBits = parseFloat(document.getElementById('stopBits').value);

        const sr = getSampleRate();
        const frames = buildBaudotFramesFromText(text);
        const signal = afskFromFrames(frames, { baud, mark, space, stopBits, sampleRate: sr });
        if (!signal.length) throw new Error('Empty PCM');

        const wav = encodeWav(signal, sr);
        const url = URL.createObjectURL(new Blob([wav], { type:'audio/wav' }));
        audioEl.pause(); audioEl.src = url; audioEl.load();
      } catch (e) {
        console.error('Audio generation error:', e);
        alert('Audio generation failed: ' + (e.message || e));
      }
    }

    function generateWavAFSK() {
      const textInput = document.getElementById('textInput').value;
      makeAudio(normalizeText(textInput), document.getElementById('audioPlayer'));
    }
  </script>
</body>
</html>
